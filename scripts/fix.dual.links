#!/bin/bash
# Web4Articles - Dual Link Fixer
# Automatically fixes dual links in all markdown files to comply with requirement e8535c4e-591d-4955-9874-6a853545e970
# Usage: fix.dual.links [file-or-directory]

set -e

# Ensure non-interactive mode
export DEBIAN_FRONTEND=noninteractive
export GIT_PAGER=cat
export PAGER=cat

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Find project root
find_project_root() {
    local current_dir="$(pwd)"
    while [[ "$current_dir" != "/" ]]; do
        if [[ -f "$current_dir/.git/config" ]] || [[ -d "$current_dir/.git" ]]; then
            echo "$current_dir"
            return 0
        fi
        current_dir="$(dirname "$current_dir")"
    done
    echo "Error: Not in a git repository" >&2
    exit 1
}

PROJECT_ROOT=$(find_project_root)
# Source environment with non-interactive settings
if [[ -f "$PROJECT_ROOT/source.env" ]]; then
    source "$PROJECT_ROOT/source.env" >/dev/null 2>&1 || true
fi

# Output header information without buffering
printf "%b" "${BLUE}üîß Web4Articles Dual Link Fixer${NC}\n"
printf "%b" "${BLUE}üìã Requirement: e8535c4e-591d-4955-9874-6a853545e970${NC}\n"
printf "%b" "${BLUE}üéØ Project Root: $PROJECT_ROOT${NC}\n\n"
printf "%b" "${YELLOW}üìå Dual Link Standard:${NC}\n"
printf "%b" "   ${GREEN}[GitHub](URL) | [¬ß/path/from/root](../../../relative/path)${NC}\n"
printf "%b" "   ${GREEN}[GitHub](URL) | [local/path](local/path)${NC} (for simple relative paths)\n\n"

# Function to calculate relative path from document to target
calculate_relative_path() {
    local doc_path="$1"
    local target_path="$2"
    
    # Get absolute paths
    local doc_dir="$(dirname "$(realpath "$doc_path")")"
    local target_abs="$(realpath "$target_path" 2>/dev/null || echo "$PROJECT_ROOT/$target_path")"
    
    # Calculate relative path using Python for accuracy (non-interactive)
    python3 -u -c "
import os.path
doc_dir = '$doc_dir'
target = '$target_abs'
try:
    rel_path = os.path.relpath(target, doc_dir)
    print(rel_path)
except:
    print('$target_path')
"
}

# Function to fix dual links in a markdown file
fix_markdown_file() {
    local md_file="$1"
    local backup_file="${md_file}.bak"
    
    echo -e "${YELLOW}üìÑ Processing: ${md_file#$PROJECT_ROOT/}${NC}"
    
    # Create backup
    cp "$md_file" "$backup_file"
    
    # Create temporary file for processing
    local temp_file=$(mktemp)
    
    # Process the file line by line
    local changes_made=0
    local line_num=0
    
    while IFS= read -r line; do
        line_num=$((line_num + 1))
        
        # Check if line contains dual link pattern: [GitHub](...) | [local](path)
        if echo "$line" | grep -qE '\[GitHub\]\([^)]+\)[[:space:]]*\|[[:space:]]*\[[^]]*\]\([^)]+\)'; then
            # Extract parts using sed
            local github_url=$(echo "$line" | sed -E 's/.*\[GitHub\]\(([^)]+)\).*/\1/')
            local display_text=$(echo "$line" | sed -E 's/.*\|[[:space:]]*\[([^]]*)\]\([^)]+\).*/\1/')
            local local_path=$(echo "$line" | sed -E 's/.*\|[[:space:]]*\[[^]]*\]\(([^)]+)\).*/\1/')
            
            # Extract the file path from GitHub URL to validate consistency
            local github_path=""
            if [[ "$github_url" =~ github\.com/[^/]+/[^/]+/blob/[^/]+/(.+)$ ]]; then
                github_path="${BASH_REMATCH[1]}"
            fi
            
            # Determine if we need to fix this link
            local needs_fix=false
            local new_display="$display_text"
            local new_path="$local_path"
            
            # Check if local path is absolute or doesn't match standard
            if [[ "$local_path" == /* ]] && [[ "$local_path" != "$PROJECT_ROOT"* ]]; then
                # Absolute path that's not from project root
                needs_fix=true
                # Try to make it relative
                if [[ -e "$PROJECT_ROOT$local_path" ]]; then
                    new_path=$(calculate_relative_path "$md_file" "$PROJECT_ROOT$local_path")
                    new_display="¬ß$local_path"
                fi
            elif [[ "$local_path" != ../* ]] && [[ "$local_path" != ./* ]] && [[ ! "$local_path" =~ ^[a-zA-Z0-9] ]]; then
                # Path that doesn't start with ../ or ./ or alphanumeric (likely absolute)
                needs_fix=true
            elif [[ "$display_text" != "¬ß"* ]] && [[ "$display_text" == /* ]]; then
                # Display text looks like an absolute path but isn't using ¬ß notation
                needs_fix=true
                new_display="¬ß$display_text"
            elif [[ "$display_text" == "$local_path" ]] && [[ "$local_path" != ../* ]]; then
                # Display and path are identical and not relative - likely needs fixing
                if [[ -e "$PROJECT_ROOT/$local_path" ]]; then
                    needs_fix=true
                    new_display="¬ß/$local_path"
                    new_path=$(calculate_relative_path "$md_file" "$PROJECT_ROOT/$local_path")
                fi
            elif [[ "$display_text" == "¬ß/components/"* ]] && [[ "$local_path" == "../../components/"* ]]; then
                # Pattern: [¬ß/components/path](../../components/path) - path duplication issue
                if [[ -e "$PROJECT_ROOT/${display_text#¬ß/}" ]]; then
                    needs_fix=true
                    new_path=$(calculate_relative_path "$md_file" "$PROJECT_ROOT/${display_text#¬ß/}")
                    # Keep display text as is (already correct with ¬ß/)
                fi
            fi
            
            # Additional check: if GitHub path exists, ensure local path is consistent
            if [[ -n "$github_path" ]] && [[ "$github_path" != "$local_path" ]]; then
                # Check if the GitHub path matches what we expect
                local expected_path=$(calculate_relative_path "$md_file" "$PROJECT_ROOT/$github_path")
                if [[ "$local_path" != "$expected_path" ]] && [[ -e "$PROJECT_ROOT/$github_path" ]]; then
                    needs_fix=true
                    new_display="¬ß/$github_path"
                    new_path="$expected_path"
                fi
            fi
            
            if [[ "$needs_fix" == true ]]; then
                # Build the new line
                local new_line="[GitHub]($github_url) | [$new_display]($new_path)"
                
                # Replace the line (preserving any leading whitespace)
                local leading_space="${line%%[![:space:]]*}"
                echo "${leading_space}${new_line}" >> "$temp_file"
                
                changes_made=$((changes_made + 1))
                echo -e "   ${GREEN}‚úÖ Line $line_num: Fixed dual link${NC}"
                echo -e "      Old: [$display_text]($local_path)"
                echo -e "      New: [$new_display]($new_path)"
            else
                echo "$line" >> "$temp_file"
            fi
        else
            echo "$line" >> "$temp_file"
        fi
    done < "$md_file"
    
    # Replace original file if changes were made
    if [[ $changes_made -gt 0 ]]; then
        mv "$temp_file" "$md_file"
        echo -e "   ${GREEN}‚úÖ Fixed $changes_made dual links${NC}"
        rm "$backup_file"
        return 0
    else
        rm "$temp_file"
        rm "$backup_file"
        echo -e "   ${BLUE}‚ÑπÔ∏è  No dual links needed fixing${NC}"
        return 1
    fi
}

# Function to check if a file should be processed
should_process_file() {
    local file="$1"
    
    # Skip certain directories
    if [[ "$file" == *"/node_modules/"* ]] || \
       [[ "$file" == *"/.git/"* ]] || \
       [[ "$file" == *"/target/"* ]] || \
       [[ "$file" == *"/dist/"* ]] || \
       [[ "$file" == *"/.next/"* ]]; then
        return 1
    fi
    
    # Only process markdown files
    if [[ "$file" == *.md ]]; then
        return 0
    fi
    
    return 1
}

# Function to process directory recursively
process_directory() {
    local dir="$1"
    local total_files=0
    local fixed_files=0
    
    echo -e "${BLUE}üìÅ Processing directory: ${dir#$PROJECT_ROOT/}${NC}"
    echo ""
    
    # Find all markdown files
    while IFS= read -r -d '' file; do
        if should_process_file "$file"; then
            total_files=$((total_files + 1))
            if fix_markdown_file "$file"; then
                fixed_files=$((fixed_files + 1))
            fi
        fi
    done < <(find "$dir" -type f -name "*.md" -print0 2>/dev/null)
    
    echo ""
    echo -e "${GREEN}üìä Summary: Processed $total_files files, fixed $fixed_files files${NC}"
}

# Function to run verification check
verify_dual_links() {
    local target="${1:-$PROJECT_ROOT}"
    
    echo -e "${BLUE}üîç Verifying dual links in: ${target#$PROJECT_ROOT/}${NC}"
    echo ""
    
    local issues_found=0
    
    # Find all dual links that might not comply
    while IFS= read -r -d '' file; do
        if should_process_file "$file"; then
            local line_num=0
            while IFS= read -r line; do
                line_num=$((line_num + 1))
                if echo "$line" | grep -qE '\[GitHub\]\([^)]+\)[[:space:]]*\|[[:space:]]*\[[^]]*\]\([^)]+\)'; then
                    local display_text=$(echo "$line" | sed -E 's/.*\|[[:space:]]*\[([^]]*)\]\([^)]+\).*/\1/')
                    local local_path=$(echo "$line" | sed -E 's/.*\|[[:space:]]*\[[^]]*\]\(([^)]+)\).*/\1/')
                    
                    # Check for potential issues
                    if [[ "$local_path" == /* ]] && [[ "$local_path" != "$PROJECT_ROOT"* ]] && [[ "$display_text" != "¬ß"* ]]; then
                        echo -e "${YELLOW}‚ö†Ô∏è  ${file#$PROJECT_ROOT/}:$line_num - Absolute path without ¬ß notation${NC}"
                        issues_found=$((issues_found + 1))
                    elif [[ "$display_text" == "$local_path" ]] && [[ "$local_path" != ../* ]] && [[ "$local_path" != ./* ]]; then
                        echo -e "${YELLOW}‚ö†Ô∏è  ${file#$PROJECT_ROOT/}:$line_num - Display matches path (not using ¬ß notation)${NC}"
                        issues_found=$((issues_found + 1))
                    fi
                fi
            done < "$file"
        fi
    done < <(find "$target" -type f -name "*.md" -print0 2>/dev/null)
    
    if [[ $issues_found -eq 0 ]]; then
        echo -e "${GREEN}‚úÖ All dual links comply with the standard!${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Found $issues_found potential issues${NC}"
    fi
}

# Main execution
main() {
    local target="${1:-$PROJECT_ROOT}"
    local verify_only="${2:-}"
    
    # Check if target exists
    if [[ ! -e "$target" ]]; then
        echo -e "${RED}‚ùå Target not found: $target${NC}"
        exit 1
    fi
    
    # Normalize path
    target="$(realpath "$target")"
    
    if [[ "$verify_only" == "--verify" ]]; then
        verify_dual_links "$target"
        exit 0
    fi
    
    echo -e "${BLUE}üéØ Target: ${target#$PROJECT_ROOT/}${NC}"
    echo ""
    
    if [[ -f "$target" ]]; then
        # Single file
        if fix_markdown_file "$target"; then
            echo -e "${GREEN}‚úÖ Successfully fixed dual links in: ${target#$PROJECT_ROOT/}${NC}"
        else
            echo -e "${BLUE}‚ÑπÔ∏è  No changes needed in: ${target#$PROJECT_ROOT/}${NC}"
        fi
    elif [[ -d "$target" ]]; then
        # Directory
        process_directory "$target"
    else
        echo -e "${RED}‚ùå Target is neither file nor directory: $target${NC}"
        exit 1
    fi
    
    echo ""
    echo -e "${GREEN}üéâ Dual Link fixing complete!${NC}"
    echo -e "${BLUE}üìã Compliance with requirement: e8535c4e-591d-4955-9874-6a853545e970${NC}"
}

# Show usage if help requested
if [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
    echo "Usage: $0 [file-or-directory] [--verify]"
    echo ""
    echo "Automatically fixes dual links in markdown files to comply with dual link standard."
    echo "Uses ¬ß notation for readable display and correct relative paths for functionality."
    echo ""
    echo "Options:"
    echo "  file-or-directory    Target file or directory (default: project root)"
    echo "  --verify            Only verify compliance, don't fix"
    echo "  --help, -h          Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0                                    # Fix all dual links in project"
    echo "  $0 scrum.pmo/                        # Fix all dual links in scrum.pmo"
    echo "  $0 path/to/specific.md               # Fix specific markdown file"
    echo "  $0 . --verify                        # Verify all dual links"
    echo ""
    echo "Dual Link Format (per requirement e8535c4e-591d-4955-9874-6a853545e970):"
    echo "  [GitHub](url) | [¬ß/path/from/root](../../../relative/path)"
    echo "  [GitHub](url) | [local/path](local/path) (for simple relative paths)"
    echo ""
    echo "The script will:"
    echo "  - Convert absolute paths to relative paths from document location"
    echo "  - Add ¬ß notation for paths from project root"
    echo "  - Ensure consistency between GitHub URL and local path"
    echo "  - Preserve existing correct dual links"
    exit 0
fi

main "$@"