#!/bin/bash
# Web4Articles - Dual Link Fixer
# Automatically fixes dual links in all markdown files to comply with requirement e8535c4e-591d-4955-9874-6a853545e970
# Usage: fix.dual.links [file-or-directory]

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Find project root
find_project_root() {
    local current_dir="$(pwd)"
    while [[ "$current_dir" != "/" ]]; do
        if [[ -f "$current_dir/.git/config" ]] || [[ -d "$current_dir/.git" ]]; then
            echo "$current_dir"
            return 0
        fi
        current_dir="$(dirname "$current_dir")"
    done
    echo "Error: Not in a git repository" >&2
    exit 1
}

PROJECT_ROOT=$(find_project_root)
source "$PROJECT_ROOT/source.env" >/dev/null 2>&1 || true

echo -e "${BLUE}ðŸ”§ Web4Articles Dual Link Fixer${NC}"
echo -e "${BLUE}ðŸ“‹ Requirement: e8535c4e-591d-4955-9874-6a853545e970${NC}"
echo -e "${BLUE}ðŸŽ¯ Project Root: $PROJECT_ROOT${NC}"
echo ""
echo -e "${YELLOW}ðŸ“Œ Dual Link Standard:${NC}"
echo -e "   ${GREEN}[GitHub](URL) | [Â§/path/from/root](../../../relative/path)${NC}"
echo -e "   ${GREEN}[GitHub](URL) | [local/path](local/path)${NC} (for simple relative paths)"
echo ""

# Function to calculate relative path from document to target
calculate_relative_path() {
    local doc_path="$1"
    local target_path="$2"
    
    # Get absolute paths
    local doc_dir="$(dirname "$(realpath "$doc_path")")"
    local target_abs="$(realpath "$target_path" 2>/dev/null || echo "$PROJECT_ROOT/$target_path")"
    
    # Calculate relative path using Python for accuracy
    python3 -c "
import os.path
doc_dir = '$doc_dir'
target = '$target_abs'
try:
    rel_path = os.path.relpath(target, doc_dir)
    print(rel_path)
except:
    print('$target_path')
"
}

# Function to fix dual links in a markdown file
fix_markdown_file() {
    local md_file="$1"
    local backup_file="${md_file}.bak"
    
    echo -e "${YELLOW}ðŸ“„ Processing: ${md_file#$PROJECT_ROOT/}${NC}"
    
    # Create backup
    cp "$md_file" "$backup_file"
    
    # Create temporary file for processing
    local temp_file=$(mktemp)
    
    # Process the file line by line
    local changes_made=0
    local line_num=0
    
    while IFS= read -r line; do
        line_num=$((line_num + 1))
        
        # Check if line contains dual link pattern: [GitHub](...) | [local](path)
        if echo "$line" | grep -qE '\[GitHub\]\([^)]+\)[[:space:]]*\|[[:space:]]*\[[^]]*\]\([^)]+\)'; then
            # Extract parts using sed
            local github_url=$(echo "$line" | sed -E 's/.*\[GitHub\]\(([^)]+)\).*/\1/')
            local display_text=$(echo "$line" | sed -E 's/.*\|[[:space:]]*\[([^]]*)\]\([^)]+\).*/\1/')
            local local_path=$(echo "$line" | sed -E 's/.*\|[[:space:]]*\[[^]]*\]\(([^)]+)\).*/\1/')
            
            # Extract the file path from GitHub URL to validate consistency
            local github_path=""
            if [[ "$github_url" =~ github\.com/[^/]+/[^/]+/blob/[^/]+/(.+)$ ]]; then
                github_path="${BASH_REMATCH[1]}"
            fi
            
            # Determine if we need to fix this link
            local needs_fix=false
            local new_display="$display_text"
            local new_path="$local_path"
            
            # Check if local path is absolute or doesn't match standard
            if [[ "$local_path" == /* ]] && [[ "$local_path" != "$PROJECT_ROOT"* ]]; then
                # Absolute path that's not from project root
                needs_fix=true
                # Try to make it relative
                if [[ -e "$PROJECT_ROOT$local_path" ]]; then
                    new_path=$(calculate_relative_path "$md_file" "$PROJECT_ROOT$local_path")
                    new_display="Â§$local_path"
                fi
            elif [[ "$local_path" != ../* ]] && [[ "$local_path" != ./* ]] && [[ ! "$local_path" =~ ^[a-zA-Z0-9] ]]; then
                # Path that doesn't start with ../ or ./ or alphanumeric (likely absolute)
                needs_fix=true
            elif [[ "$display_text" != "Â§"* ]] && [[ "$display_text" == /* ]]; then
                # Display text looks like an absolute path but isn't using Â§ notation
                needs_fix=true
                new_display="Â§$display_text"
            elif [[ "$display_text" == "$local_path" ]] && [[ "$local_path" != ../* ]]; then
                # Display and path are identical and not relative - likely needs fixing
                if [[ -e "$PROJECT_ROOT/$local_path" ]]; then
                    needs_fix=true
                    new_display="Â§/$local_path"
                    new_path=$(calculate_relative_path "$md_file" "$PROJECT_ROOT/$local_path")
                fi
            fi
            
            # Additional check: if GitHub path exists, ensure local path is consistent
            if [[ -n "$github_path" ]] && [[ "$github_path" != "$local_path" ]]; then
                # Check if the GitHub path matches what we expect
                local expected_path=$(calculate_relative_path "$md_file" "$PROJECT_ROOT/$github_path")
                if [[ "$local_path" != "$expected_path" ]] && [[ -e "$PROJECT_ROOT/$github_path" ]]; then
                    needs_fix=true
                    new_display="Â§/$github_path"
                    new_path="$expected_path"
                fi
            fi
            
            if [[ "$needs_fix" == true ]]; then
                # Build the new line
                local new_line="[GitHub]($github_url) | [$new_display]($new_path)"
                
                # Replace the line (preserving any leading whitespace)
                local leading_space="${line%%[![:space:]]*}"
                echo "${leading_space}${new_line}" >> "$temp_file"
                
                changes_made=$((changes_made + 1))
                echo -e "   ${GREEN}âœ… Line $line_num: Fixed dual link${NC}"
                echo -e "      Old: [$display_text]($local_path)"
                echo -e "      New: [$new_display]($new_path)"
            else
                echo "$line" >> "$temp_file"
            fi
        else
            echo "$line" >> "$temp_file"
        fi
    done < "$md_file"
    
    # Replace original file if changes were made
    if [[ $changes_made -gt 0 ]]; then
        mv "$temp_file" "$md_file"
        echo -e "   ${GREEN}âœ… Fixed $changes_made dual links${NC}"
        rm "$backup_file"
        return 0
    else
        rm "$temp_file"
        rm "$backup_file"
        echo -e "   ${BLUE}â„¹ï¸  No dual links needed fixing${NC}"
        return 1
    fi
}

# Function to check if a file should be processed
should_process_file() {
    local file="$1"
    
    # Skip certain directories
    if [[ "$file" == *"/node_modules/"* ]] || \
       [[ "$file" == *"/.git/"* ]] || \
       [[ "$file" == *"/target/"* ]] || \
       [[ "$file" == *"/dist/"* ]] || \
       [[ "$file" == *"/.next/"* ]]; then
        return 1
    fi
    
    # Only process markdown files
    if [[ "$file" == *.md ]]; then
        return 0
    fi
    
    return 1
}

# Function to process directory recursively
process_directory() {
    local dir="$1"
    local total_files=0
    local fixed_files=0
    
    echo -e "${BLUE}ðŸ“ Processing directory: ${dir#$PROJECT_ROOT/}${NC}"
    echo ""
    
    # Find all markdown files
    while IFS= read -r -d '' file; do
        if should_process_file "$file"; then
            total_files=$((total_files + 1))
            if fix_markdown_file "$file"; then
                fixed_files=$((fixed_files + 1))
            fi
        fi
    done < <(find "$dir" -type f -name "*.md" -print0)
    
    echo ""
    echo -e "${GREEN}ðŸ“Š Summary: Processed $total_files files, fixed $fixed_files files${NC}"
}

# Function to run verification check
verify_dual_links() {
    local target="${1:-$PROJECT_ROOT}"
    
    echo -e "${BLUE}ðŸ” Verifying dual links in: ${target#$PROJECT_ROOT/}${NC}"
    echo ""
    
    local issues_found=0
    
    # Find all dual links that might not comply
    while IFS= read -r -d '' file; do
        if should_process_file "$file"; then
            local line_num=0
            while IFS= read -r line; do
                line_num=$((line_num + 1))
                if echo "$line" | grep -qE '\[GitHub\]\([^)]+\)[[:space:]]*\|[[:space:]]*\[[^]]*\]\([^)]+\)'; then
                    local display_text=$(echo "$line" | sed -E 's/.*\|[[:space:]]*\[([^]]*)\]\([^)]+\).*/\1/')
                    local local_path=$(echo "$line" | sed -E 's/.*\|[[:space:]]*\[[^]]*\]\(([^)]+)\).*/\1/')
                    
                    # Check for potential issues
                    if [[ "$local_path" == /* ]] && [[ "$local_path" != "$PROJECT_ROOT"* ]] && [[ "$display_text" != "Â§"* ]]; then
                        echo -e "${YELLOW}âš ï¸  ${file#$PROJECT_ROOT/}:$line_num - Absolute path without Â§ notation${NC}"
                        issues_found=$((issues_found + 1))
                    elif [[ "$display_text" == "$local_path" ]] && [[ "$local_path" != ../* ]] && [[ "$local_path" != ./* ]]; then
                        echo -e "${YELLOW}âš ï¸  ${file#$PROJECT_ROOT/}:$line_num - Display matches path (not using Â§ notation)${NC}"
                        issues_found=$((issues_found + 1))
                    fi
                fi
            done < "$file"
        fi
    done < <(find "$target" -type f -name "*.md" -print0)
    
    if [[ $issues_found -eq 0 ]]; then
        echo -e "${GREEN}âœ… All dual links comply with the standard!${NC}"
    else
        echo -e "${YELLOW}âš ï¸  Found $issues_found potential issues${NC}"
    fi
}

# Main execution
main() {
    local target="${1:-$PROJECT_ROOT}"
    local verify_only="${2:-}"
    
    # Check if target exists
    if [[ ! -e "$target" ]]; then
        echo -e "${RED}âŒ Target not found: $target${NC}"
        exit 1
    fi
    
    # Normalize path
    target="$(realpath "$target")"
    
    if [[ "$verify_only" == "--verify" ]]; then
        verify_dual_links "$target"
        exit 0
    fi
    
    echo -e "${BLUE}ðŸŽ¯ Target: ${target#$PROJECT_ROOT/}${NC}"
    echo ""
    
    if [[ -f "$target" ]]; then
        # Single file
        if fix_markdown_file "$target"; then
            echo -e "${GREEN}âœ… Successfully fixed dual links in: ${target#$PROJECT_ROOT/}${NC}"
        else
            echo -e "${BLUE}â„¹ï¸  No changes needed in: ${target#$PROJECT_ROOT/}${NC}"
        fi
    elif [[ -d "$target" ]]; then
        # Directory
        process_directory "$target"
    else
        echo -e "${RED}âŒ Target is neither file nor directory: $target${NC}"
        exit 1
    fi
    
    echo ""
    echo -e "${GREEN}ðŸŽ‰ Dual Link fixing complete!${NC}"
    echo -e "${BLUE}ðŸ“‹ Compliance with requirement: e8535c4e-591d-4955-9874-6a853545e970${NC}"
}

# Show usage if help requested
if [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
    echo "Usage: $0 [file-or-directory] [--verify]"
    echo ""
    echo "Automatically fixes dual links in markdown files to comply with dual link standard."
    echo "Uses Â§ notation for readable display and correct relative paths for functionality."
    echo ""
    echo "Options:"
    echo "  file-or-directory    Target file or directory (default: project root)"
    echo "  --verify            Only verify compliance, don't fix"
    echo "  --help, -h          Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0                                    # Fix all dual links in project"
    echo "  $0 scrum.pmo/                        # Fix all dual links in scrum.pmo"
    echo "  $0 path/to/specific.md               # Fix specific markdown file"
    echo "  $0 . --verify                        # Verify all dual links"
    echo ""
    echo "Dual Link Format (per requirement e8535c4e-591d-4955-9874-6a853545e970):"
    echo "  [GitHub](url) | [Â§/path/from/root](../../../relative/path)"
    echo "  [GitHub](url) | [local/path](local/path) (for simple relative paths)"
    echo ""
    echo "The script will:"
    echo "  - Convert absolute paths to relative paths from document location"
    echo "  - Add Â§ notation for paths from project root"
    echo "  - Ensure consistency between GitHub URL and local path"
    echo "  - Preserve existing correct dual links"
    exit 0
fi

main "$@"