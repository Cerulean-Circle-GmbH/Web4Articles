import { Requirement, RequirementScenario, RequirementResult, RequirementStatus, RequirementMetadata } from '../layer3/Requirement.js';
import * as fs from 'fs/promises';
import * as path from 'path';

export class DefaultRequirement implements Requirement {
  private scenario!: RequirementScenario;
  private uuid: string = '';
  private _name: string = '';
  private description: string = '';
  private status: RequirementStatus = RequirementStatus.PENDING;
  
  constructor() { // Web4 empty constructor
  }
  
  init(scenario: RequirementScenario): this {
    this.scenario = scenario;
    return this;
  }

  async create(title: string, description: string): Promise<RequirementResult> {
    this.uuid = this.generateUUID();
    this._name = title;
    this.description = description;
    this.status = RequirementStatus.CREATED;

    const scenario = this.createScenarioJSON();
    
    return {
      success: true,
      requirementId: this.uuid,
      scenario: scenario,
      message: 'Requirement created successfully'
    };
  }

  getUuid(): string {
    return this.uuid;
  }

  getTitle(): string {
    return this._name;
  }

  getDescription(): string {
    return this.description;
  }
  
  getMetadata(): RequirementMetadata {
    return { ...this.scenario.metadata };
  }
  
  async process(): Promise<RequirementResult> {
    return {
      success: true,
      message: 'Requirement processed successfully',
      requirementId: this.uuid
    };
  }
  
  getStatus(): RequirementStatus {
    return this.status;
  }
  
  toScenario(): RequirementScenario {
    return this.scenario;
  }

  private generateUUID(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c == 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  private createScenarioJSON(): any {
    const hostname = process.env.HOSTNAME || 'localhost';
    const user = process.env.USER || 'unknown';
    const utcTimestamp = new Date().toISOString();
    const ownerUuid = this.generateUUID();

    const owner = {
      user,
      hostname,
      utcTimestamp,
      uuid: ownerUuid
    };

    return {
      IOR: {
        uuid: this.uuid,
        component: 'Web4Requirement',
        version: 'v1.0'
      },
      owner: Buffer.from(JSON.stringify(owner)).toString('base64'),
      model: {
        uuid: this.uuid,
        name: this._name,
        title: this._name,
        description: this.description
      }
    };
  }

  // Name and title accessors
  get name(): string {
    return this._name;
  }
  
  set name(value: string) {
    this._name = value;
  }
  
  get title(): string {
    return this._name; // Title is an alias for name
  }
  
  set title(value: string) {
    this._name = value; // Setting title updates name
  }

  async loadFromScenario(scenarioPath: string): Promise<RequirementResult> {
    try {
      const scenarioContent = await fs.readFile(scenarioPath, 'utf-8');
      const scenarioData = JSON.parse(scenarioContent);
      
      // Load from IOR-based scenario structure
      if (scenarioData.IOR && scenarioData.model) {
        this.uuid = scenarioData.IOR.uuid;
        this._name = scenarioData.model.name || scenarioData.model.title || '';
        this.description = scenarioData.model.description || '';
        this.status = RequirementStatus.CREATED; // Assume loaded requirements are created
        
        // Reconstruct minimal scenario for compatibility
        this.scenario = {
          uuid: this.uuid,
          name: this._name,
          title: this._name,
          description: this.description,
          status: this.status,
          metadata: { priority: 'medium', complexity: 'moderate', tags: [] },
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
        
        return {
          success: true,
          message: `Requirement loaded from scenario: ${scenarioPath}`,
          requirementId: this.uuid
        };
      } else {
        return {
          success: false,
          message: `Invalid scenario format in ${scenarioPath}`,
          issues: ['Missing IOR or model structure']
        };
      }
    } catch (error) {
      return {
        success: false,
        message: `Failed to load scenario: ${(error as Error).message}`,
        issues: [(error as Error).message]
      };
    }
  }

  generateMDView(): string {
    const mdContent = `# ${this._name}

## Requirement Details

- **UUID:** \`${this.uuid}\`
- **Name:** ${this._name}
- **Title:** ${this._name}
- **Status:** ${this.status}

## Description

${this.description}

## Metadata

- **Created:** ${new Date().toISOString()}
- **Updated:** ${new Date().toISOString()}

---

*Generated by Web4Requirement Component v1.0*
`;
    
    return mdContent;
  }

  async saveMDView(outputPath?: string): Promise<RequirementResult> {
    try {
      const filename = `${this.uuid}.requirement.md`;
      const filePath = outputPath ? path.join(outputPath, filename) : filename;
      
      // Ensure output directory exists
      if (outputPath) {
        await fs.mkdir(outputPath, { recursive: true });
      }
      
      const mdContent = this.generateMDView();
      await fs.writeFile(filePath, mdContent, 'utf-8');
      
      // Update requirements overview
      if (outputPath) {
        await this.updateRequirementsOverview(outputPath);
      }
      
      return {
        success: true,
        message: `MD view saved: ${filePath}`,
        requirementId: this.uuid
      };
    } catch (error) {
      return {
        success: false,
        message: `Failed to save MD view: ${(error as Error).message}`,
        issues: [(error as Error).message]
      };
    }
  }

  private async updateRequirementsOverview(outputPath: string): Promise<void> {
    try {
      const overviewPath = path.join(outputPath, '00_requirements.overview.md');
      
      // Read all existing requirement MD files
      const files = await fs.readdir(outputPath);
      const requirementFiles = files
        .filter(file => file.endsWith('.requirement.md'))
        .sort((a, b) => {
          // Sort by creation time (newest first) - extract timestamp from UUID
          try {
            const statsA = require('fs').statSync(path.join(outputPath, a));
            const statsB = require('fs').statSync(path.join(outputPath, b));
            return statsB.mtime.getTime() - statsA.mtime.getTime();
          } catch {
            return b.localeCompare(a); // Fallback to alphabetical if stats fail
          }
        });

      // Generate overview content
      const overviewContent = await this.generateRequirementsOverview(requirementFiles, outputPath);
      
      // Write overview file
      await fs.writeFile(overviewPath, overviewContent, 'utf-8');
    } catch (error) {
      console.warn(`Failed to update requirements overview: ${(error as Error).message}`);
    }
  }

  private async generateRequirementsOverview(requirementFiles: string[], outputPath: string): Promise<string> {
    const timestamp = new Date().toISOString();
    let overviewContent = `# Requirements Overview

**Last Updated:** ${timestamp}  
**Total Requirements:** ${requirementFiles.length}

---

## Requirements List

`;

    // Process each requirement file to extract title and create link
    for (const filename of requirementFiles) {
      try {
        const filePath = path.join(outputPath, filename);
        const content = await fs.readFile(filePath, 'utf-8');
        
        // Extract title from MD content (first # heading)
        const titleMatch = content.match(/^# (.+)$/m);
        const title = titleMatch ? titleMatch[1] : filename.replace('.requirement.md', '');
        
        // Extract UUID from filename
        const uuid = filename.replace('.requirement.md', '');
        
        // Extract creation date if available
        const dateMatch = content.match(/\*\*Created:\*\* (.+)$/m);
        const createdDate = dateMatch ? new Date(dateMatch[1]).toLocaleDateString() : 'Unknown';
        
        overviewContent += `### [${title}](./${filename})

- **UUID:** \`${uuid}\`
- **Created:** ${createdDate}
- **File:** [\`${filename}\`](./${filename})

---

`;
      } catch (error) {
        // If we can't read a file, still include it in the list
        const uuid = filename.replace('.requirement.md', '');
        overviewContent += `### [${filename}](./${filename})

- **UUID:** \`${uuid}\`
- **Created:** Unknown
- **File:** [\`${filename}\`](./${filename})

---

`;
      }
    }

    overviewContent += `
## Usage

This overview is automatically generated and updated whenever a new requirement is created using the Web4Requirement component.

**Generated by:** Web4Requirement Component v1.0  
**Generation Time:** ${timestamp}
`;

    return overviewContent;
  }
}