/**
 * DefaultWeb4TSComponent - Web4 Architecture Layer 2 Implementation
 * Implements Web4 TypeScript component standards enforcement
 */

import { Web4TSComponent, ComponentMetadata, CLIStandardValidation, ComponentScaffoldOptions } from '../layer3/Web4TSComponent.js';
import * as fs from 'fs/promises';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export class DefaultWeb4TSComponent implements Web4TSComponent {
  private componentName: string = '';
  private version: string = '';
  private targetDirectory: string = '';

  // Web4 Empty Constructor Principle
  constructor() {
    // Empty constructor - configuration via setters
  }

  // Configuration methods
  setComponentName(name: string): void {
    this.componentName = name;
  }

  setVersion(version: string): void {
    this.version = version;
  }

  setTargetDirectory(directory: string): void {
    this.targetDirectory = directory;
  }

  // Standard enforcement methods
  async validateLocationResilientCLI(scriptPath: string): Promise<CLIStandardValidation> {
    try {
      const content = await fs.readFile(scriptPath, 'utf-8');
      
      const validation: CLIStandardValidation = {
        isCompliant: false,
        issues: [],
        hasProjectRootDetection: false,
        hasAutoBuilder: false,
        hasContextPreservation: false,
        hasVersionResolution: false
      };

      // Check for project root detection
      if (content.includes('git rev-parse --show-toplevel') || content.includes('find_project_root')) {
        validation.hasProjectRootDetection = true;
      } else {
        validation.issues.push('Missing project root detection logic');
      }

      // Check for auto-build integration
      if (content.includes('npm run build') && content.includes('CLI_PATH')) {
        validation.hasAutoBuilder = true;
      } else {
        validation.issues.push('Missing auto-build integration');
      }

      // Check for context preservation
      if (content.includes('CURRENT_DIR') && content.includes('cd "$CURRENT_DIR"')) {
        validation.hasContextPreservation = true;
      } else {
        validation.issues.push('Missing execution context preservation');
      }

      // Check for version resolution
      if (content.includes('COMPONENT_VERSION') && content.includes('COMPONENT_DIR')) {
        validation.hasVersionResolution = true;
      } else {
        validation.issues.push('Missing component version resolution');
      }

      validation.isCompliant = validation.issues.length === 0;
      return validation;

    } catch (error) {
      return {
        isCompliant: false,
        issues: [`Error reading script: ${(error as Error).message}`],
        hasProjectRootDetection: false,
        hasAutoBuilder: false,
        hasContextPreservation: false,
        hasVersionResolution: false
      };
    }
  }

  async generateLocationResilientCLI(componentName: string, version: string): Promise<string> {
    const cliTemplate = `#!/bin/bash

<<<<<<< HEAD
# ${componentName} CLI Tool - Location Resilient Version
# Web4 Architecture Standard - Generated by Web4TSComponent
=======
# ${componentName} CLI Tool - Location Resilient Version with Stale Prevention
# Web4 Architecture Standard - Generated by Web4TSComponent v0.1.0.0
# Implements requirement-v0.1.2.2-stale-prevention-standard
>>>>>>> origin/dev/2025-09-14-UTC-1425
# Works from any directory, finds project root via git

# Function to find project root using git
find_project_root() {
    # Try git first (most reliable)
    local git_root=$(git rev-parse --show-toplevel 2>/dev/null)
    if [ -n "$git_root" ] && [ -d "$git_root" ]; then
        # Verify it's Web4Articles project by checking for key files
        if [ -f "$git_root/package.json" ] || [ -f "$git_root/README.md" ]; then
            echo "$git_root"
            return 0
        fi
    fi
    
    # Fallback: walk up looking for .git and package.json
    local current_dir="$PWD"
    while [ "$current_dir" != "/" ]; do
        if [ -d "$current_dir/.git" ] && [ -f "$current_dir/package.json" ]; then
            echo "$current_dir"
            return 0
        fi
        current_dir="$(dirname "$current_dir")"
    done
    
    return 1
}

# Find project root
PROJECT_ROOT=$(find_project_root)
if [ -z "$PROJECT_ROOT" ]; then
    echo "‚ùå Error: Not in a Web4Articles project directory"
    echo "üí° Please run from within the Web4Articles git repository"
    exit 1
fi

export PROJECT_ROOT

# Detect context for the CLI
CURRENT_DIR="$(pwd)"
CONTEXT_INFO=""

# Check if we're in a component directory
if [[ "$CURRENT_DIR" == *"/components/"*"/"*"/"* ]]; then
    COMPONENT_PATH=$(echo "$CURRENT_DIR" | grep -o '.*/components/[^/]*/[^/]*')
    if [ -n "$COMPONENT_PATH" ]; then
        CONTEXT_INFO="component:$COMPONENT_PATH"
    fi
fi

# Default context if none detected
if [ -z "$CONTEXT_INFO" ]; then
    CONTEXT_INFO="arbitrary:$CURRENT_DIR"
fi

# Find the CLI in the components directory structure
COMPONENT_VERSION="${version}"
COMPONENT_DIR="$PROJECT_ROOT/components/${componentName}/$COMPONENT_VERSION"
CLI_SOURCE_PATH="$COMPONENT_DIR/src/ts/layer5/${componentName}CLI.ts"
CLI_PATH="$COMPONENT_DIR/dist/ts/layer5/${componentName}CLI.js"

<<<<<<< HEAD
# Check if compiled CLI exists, if not try to build
if [ ! -f "$CLI_PATH" ]; then
  if [ ! -f "$CLI_SOURCE_PATH" ]; then
    echo "‚ùå CLI source not found at: $CLI_SOURCE_PATH"
    echo "üìÅ Component directory: $COMPONENT_DIR"
    exit 1
  fi
  
  echo "üî® Building ${componentName} CLI v$COMPONENT_VERSION..."
=======
# Function to check if rebuild is needed (Web4 Stale Prevention Standard)
needs_rebuild() {
    # If CLI doesn't exist, rebuild needed
    [ ! -f "$CLI_PATH" ] && return 0
    
    # Check if any TypeScript file in src is newer than CLI
    find "$COMPONENT_DIR/src" -name "*.ts" -newer "$CLI_PATH" 2>/dev/null | grep -q . && return 0
    
    return 1
}

# Check if CLI source exists
if [ ! -f "$CLI_SOURCE_PATH" ]; then
  echo "‚ùå CLI source not found at: $CLI_SOURCE_PATH"
  echo "üìÅ Component directory: $COMPONENT_DIR"
  exit 1
fi

# Build if CLI not available or source is newer (Web4 Stale Prevention Standard)
if needs_rebuild; then
  echo "üî® Building ${componentName} CLI v$COMPONENT_VERSION (source files updated)..."
>>>>>>> origin/dev/2025-09-14-UTC-1425
  cd "$COMPONENT_DIR"
  
  # Install dependencies if needed
  if [ ! -d "node_modules" ]; then
<<<<<<< HEAD
    npm install
  fi
  
  # Build the project
  if ! npm run build; then
=======
    npm install --silent 2>/dev/null || true
  fi
  
  # Build the project
  if ! npm run build --silent; then
>>>>>>> origin/dev/2025-09-14-UTC-1425
    echo "‚ùå Build failed for ${componentName} v$COMPONENT_VERSION"
    exit 1
  fi
  
  if [ ! -f "$CLI_PATH" ]; then
    echo "‚ùå CLI still not found at: $CLI_PATH after build"
    exit 1
  fi
fi

# Check for Node.js
if ! command -v node >/dev/null 2>&1; then
    echo "‚ùå Error: Node.js is required but not installed"
    exit 1
fi

# Execute the CLI with context info and all arguments
cd "$CURRENT_DIR"
DIRECTORY_CONTEXT="$CONTEXT_INFO" node "$CLI_PATH" "$@"
`;

    return cliTemplate;
  }

  async scaffoldComponent(options: ComponentScaffoldOptions): Promise<ComponentMetadata> {
    const componentPath = path.join(this.targetDirectory, 'components', options.componentName, options.version);
    
    try {
      // Create directory structure
      await fs.mkdir(componentPath, { recursive: true });
      await fs.mkdir(path.join(componentPath, 'src/ts/layer2'), { recursive: true });
      await fs.mkdir(path.join(componentPath, 'src/ts/layer3'), { recursive: true });
      await fs.mkdir(path.join(componentPath, 'src/ts/layer5'), { recursive: true });

      if (options.includeSpecFolder) {
        await fs.mkdir(path.join(componentPath, 'spec/requirements'), { recursive: true });
        await fs.mkdir(path.join(componentPath, 'spec/requirements.md'), { recursive: true });
      }

      // Generate package.json
      const packageJson = {
        name: `@web4x/${options.componentName.toLowerCase()}`,
        version: options.version,
        type: "module",
        description: `Web4 ${options.componentName} Component`,
        main: `src/ts/layer5/${options.componentName}CLI.ts`,
        scripts: {
          build: "tsc",
          ...(options.includeVitest ? { test: "vitest" } : {}),
          start: `node -r ts-node/register src/ts/layer5/${options.componentName}CLI.ts`
        },
        devDependencies: {
          "@types/node": "^20.0.0",
          "ts-node": "^10.9.0",
          "typescript": "^5.0.0",
          ...(options.includeVitest ? { vitest: "^1.0.0" } : {})
        }
      };

      await fs.writeFile(
        path.join(componentPath, 'package.json'),
        JSON.stringify(packageJson, null, 2)
      );

      // Generate tsconfig.json
      const tsConfig = {
        compilerOptions: {
          target: "ES2022",
          module: "ESNext",
          moduleResolution: "node",
          declaration: true,
          declarationMap: true,
          sourceMap: true,
          outDir: "./dist",
          rootDir: "./src",
          removeComments: false,
          strict: true,
          esModuleInterop: true,
          skipLibCheck: true,
          forceConsistentCasingInFileNames: true
        },
        include: ["src/**/*"],
        exclude: ["node_modules", "dist"]
      };

      await fs.writeFile(
        path.join(componentPath, 'tsconfig.json'),
        JSON.stringify(tsConfig, null, 2)
      );

      // Generate CLI if requested
      if (options.includeCLI) {
        const cliScript = await this.generateLocationResilientCLI(options.componentName, options.version);
        await fs.writeFile(path.join(componentPath, `${options.componentName.toLowerCase()}.sh`), cliScript);
      }

      const metadata: ComponentMetadata = {
        name: options.componentName,
        version: options.version,
        type: 'Web4Component',
        hasLocationResilientCLI: options.includeCLI,
        hasEmptyConstructors: true,
        hasScenarioSupport: true,
        hasLayeredArchitecture: options.includeLayerArchitecture
      };

      return metadata;

    } catch (error) {
      throw new Error(`Failed to scaffold component: ${(error as Error).message}`);
    }
  }

  async auditComponentCompliance(componentPath: string): Promise<ComponentMetadata> {
    const packageJsonPath = path.join(componentPath, 'package.json');
    const tsConfigPath = path.join(componentPath, 'tsconfig.json');
    
    try {
      const packageContent = await fs.readFile(packageJsonPath, 'utf-8');
      const packageData = JSON.parse(packageContent);

      const metadata: ComponentMetadata = {
        name: packageData.name || 'Unknown',
        version: packageData.version || 'Unknown',
        type: 'Web4Component',
        hasLocationResilientCLI: false,
        hasEmptyConstructors: false,
        hasScenarioSupport: false,
        hasLayeredArchitecture: false
      };

      // Check for layered architecture
      try {
        await fs.access(path.join(componentPath, 'src/ts/layer2'));
        await fs.access(path.join(componentPath, 'src/ts/layer3'));
        await fs.access(path.join(componentPath, 'src/ts/layer5'));
        metadata.hasLayeredArchitecture = true;
      } catch {
        // Layers not found
      }

      // Check for CLI script
      const files = await fs.readdir(componentPath);
      const cliScript = files.find(f => f.endsWith('.sh'));
      if (cliScript) {
        const validation = await this.validateLocationResilientCLI(path.join(componentPath, cliScript));
        metadata.hasLocationResilientCLI = validation.isCompliant;
      }

      return metadata;

    } catch (error) {
      throw new Error(`Failed to audit component: ${(error as Error).message}`);
    }
  }

  async generateComplianceReport(components: string[]): Promise<string> {
    let report = '# Web4 Component Compliance Report\\n\\n';
    
    for (const componentPath of components) {
      try {
        const metadata = await this.auditComponentCompliance(componentPath);
        
        report += `## ${metadata.name} v${metadata.version}\\n`;
        report += `- Location-Resilient CLI: ${metadata.hasLocationResilientCLI ? '‚úÖ' : '‚ùå'}\\n`;
        report += `- Layered Architecture: ${metadata.hasLayeredArchitecture ? '‚úÖ' : '‚ùå'}\\n`;
        report += `- Empty Constructors: ${metadata.hasEmptyConstructors ? '‚úÖ' : '‚ö†Ô∏è (Not verified)'}\\n`;
        report += `- Scenario Support: ${metadata.hasScenarioSupport ? '‚úÖ' : '‚ö†Ô∏è (Not verified)'}\\n\\n`;
        
      } catch (error) {
        report += `## ${componentPath}\\n`;
        report += `- Error: ${(error as Error).message}\\n\\n`;
      }
    }
    
    return report;
  }

  getLocationResilientCLIStandard(): string {
    return `# Web4 Location-Resilient CLI Standard

## Overview
All Web4 components must provide CLIs that work from any directory within the project.

## Required Features
1. **Project Root Detection**: Use git rev-parse or directory traversal
2. **Component Version Resolution**: Locate CLI in components/[Name]/[Version] structure  
3. **Auto-Build Integration**: Build component if CLI not compiled
4. **Context Preservation**: Return to original execution directory

## Implementation Pattern
Use Web4TSComponent.generateLocationResilientCLI() to create standard-compliant scripts.

## Validation
Use Web4TSComponent.validateLocationResilientCLI() to check compliance.
`;
  }

  getWeb4ArchitectureGuidelines(): string {
    return `# Web4 Architecture Guidelines

## Core Principles
1. **Empty Constructor Principle**: All classes must have empty constructors
2. **Scenario-First Development**: Objects are hibernatable scenarios
3. **IOR Architecture**: Reference objects by Interoperable Object References
4. **Semantic Invariants**: Location, format, and other implementation details are irrelevant
5. **Layered Architecture**: Layer 2 (Implementation), Layer 3 (Interface), Layer 5 (CLI/UI)

## Component Structure
- src/ts/layer2/: Implementation classes
- src/ts/layer3/: Interface definitions  
- src/ts/layer5/: CLI and UI components
- spec/requirements/: Scenario files
- spec/requirements.md/: Generated documentation

## Standards Compliance
Use Web4TSComponent for scaffolding and validation.
`;
  }

  // Scenario support (Web4 Scenario-First Development)
  toScenario(): any {
    return {
      ior: {
        uuid: 'web4tscomponent-' + Date.now(),
        type: 'Web4TSComponent',
        version: '0.1.0.0'
      },
      model: {
        componentName: this.componentName,
        version: this.version,
        targetDirectory: this.targetDirectory,
        created: new Date().toISOString(),
        updated: new Date().toISOString()
      }
    };
  }

  fromScenario(scenario: any): void {
    if (scenario.model) {
      this.componentName = scenario.model.componentName || '';
      this.version = scenario.model.version || '';
      this.targetDirectory = scenario.model.targetDirectory || '';
    }
  }
}



