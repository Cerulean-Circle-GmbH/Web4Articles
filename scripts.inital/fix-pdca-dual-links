#!/bin/bash
# Web4Articles - PDCA Dual Link Fixer
# Automatically fixes dual links in PDCA files to comply with requirement e8535c4e-591d-4955-9874-6a853545e970
# Usage: fix-pdca-dual-links [file-or-directory]

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Find project root
find_project_root() {
    local current_dir="$(pwd)"
    while [[ "$current_dir" != "/" ]]; do
        if [[ -f "$current_dir/.git/config" ]] || [[ -d "$current_dir/.git" ]]; then
            echo "$current_dir"
            return 0
        fi
        current_dir="$(dirname "$current_dir")"
    done
    echo "Error: Not in a git repository" >&2
    exit 1
}

PROJECT_ROOT=$(find_project_root)
source "$PROJECT_ROOT/source.env" >/dev/null 2>&1 || true

echo -e "${BLUE}🔧 Web4Articles PDCA Dual Link Fixer${NC}"
echo -e "${BLUE}📋 Requirement: e8535c4e-591d-4955-9874-6a853545e970${NC}"
echo -e "${BLUE}🎯 Project Root: $PROJECT_ROOT${NC}"

# Function to calculate relative path from document to project root
calculate_relative_path() {
    local doc_path="$1"
    local doc_dir="$(dirname "$doc_path")"
    local rel_path=""
    
    # Get absolute path to document directory
    doc_dir="$(realpath "$doc_dir")"
    
    # Count directory depth from project root by counting path components
    local relative_to_root="${doc_dir#$PROJECT_ROOT/}"
    
    # Handle case where document is in project root
    if [[ "$relative_to_root" == "$doc_dir" ]] || [[ -z "$relative_to_root" ]]; then
        echo "."
        return
    fi
    
    # Count actual directory levels (non-empty components only)
    local depth=0
    IFS='/' read -ra ADDR <<< "$relative_to_root"
    for component in "${ADDR[@]}"; do
        if [[ -n "$component" ]]; then
            depth=$((depth + 1))
        fi
    done
    
    # Build relative path with correct number of ../
    for ((i=0; i<depth; i++)); do
        rel_path="../$rel_path"
    done
    
    # Remove trailing slash if present
    rel_path="${rel_path%/}"
    
    echo "$rel_path"
}

# Function to fix dual links in a single PDCA file
fix_pdca_file() {
    local pdca_file="$1"
    local backup_file="${pdca_file}.bak"
    
    echo -e "${YELLOW}📄 Processing: $pdca_file${NC}"
    
    # Create backup
    cp "$pdca_file" "$backup_file"
    
    # Calculate relative path from this document to project root
    local rel_path=$(calculate_relative_path "$pdca_file")
    if [[ -z "$rel_path" ]]; then
        rel_path="."
    fi
    
    echo -e "   📍 Relative path to project root: ${rel_path}"
    
    # Create temporary file for processing
    local temp_file=$(mktemp)
    
    # Process the file line by line
    local changes_made=0
    while IFS= read -r line; do
        # Check if line contains dual link pattern: [GitHub](...) | [local](path)
        if [[ "$line" =~ \[GitHub\]\([^)]+\)[[:space:]]*\|[[:space:]]*\[([^]]*)\]\(([^)]+)\) ]]; then
            local display_text="${BASH_REMATCH[1]}"
            local local_path="${BASH_REMATCH[2]}"
            
            # Skip if already using § notation
            if [[ "$display_text" == "§"/* ]]; then
                echo "$line" >> "$temp_file"
                continue
            fi
            
            # Convert absolute project paths to § notation and relative paths
            if [[ "$local_path" == "$PROJECT_ROOT"* ]]; then
                # Convert absolute path to project-relative
                local project_rel_path="${local_path#$PROJECT_ROOT/}"
                local new_display="§/$project_rel_path"
                local new_local_path="$rel_path/$project_rel_path"
                
                # Replace the local link part
                local new_line=$(echo "$line" | sed -E "s|\[([^]]*)\]\(([^)]+)\)(\s*)$|[$new_display]($new_local_path)|")
                echo "$new_line" >> "$temp_file"
                changes_made=$((changes_made + 1))
                echo -e "   ✅ Fixed: $display_text → $new_display"
            elif [[ "$local_path" == /* ]] && [[ ! "$local_path" == "$rel_path"* ]]; then
                # Absolute path that's not project root - try to make relative
                if [[ "$local_path" == "$PROJECT_ROOT"* ]]; then
                    local project_rel_path="${local_path#$PROJECT_ROOT/}"
                    local new_display="§/$project_rel_path"  
                    local new_local_path="$rel_path/$project_rel_path"
                    
                    local new_line=$(echo "$line" | sed -E "s|\[([^]]*)\]\(([^)]+)\)(\s*)$|[$new_display]($new_local_path)|")
                    echo "$new_line" >> "$temp_file"
                    changes_made=$((changes_made + 1))
                    echo -e "   ✅ Fixed absolute path: $local_path → $new_display"
                else
                    echo "$line" >> "$temp_file"
                fi
            elif [[ "$local_path" == ../* ]]; then
                # Already relative path - convert display to § notation if possible
                # Try to resolve the relative path to see if it's in project
                local resolved_path="$(cd "$(dirname "$pdca_file")" && realpath "$local_path" 2>/dev/null || echo "")"
                if [[ "$resolved_path" == "$PROJECT_ROOT"* ]] && [[ -n "$resolved_path" ]]; then
                    local project_rel_path="${resolved_path#$PROJECT_ROOT/}"
                    local new_display="§/$project_rel_path"
                    
                    local new_line=$(echo "$line" | sed -E "s|\[([^]]*)\]\(([^)]+)\)|[$new_display]($local_path)|")
                    echo "$new_line" >> "$temp_file"
                    changes_made=$((changes_made + 1))
                    echo -e "   ✅ Updated display: $display_text → $new_display"
                else
                    echo "$line" >> "$temp_file"
                fi
            elif [[ ! "$local_path" == $rel_path* ]] && [[ -f "$(dirname "$pdca_file")/$local_path" ]]; then
                # Relative path that needs to be updated to use project root reference
                local resolved_path="$(cd "$(dirname "$pdca_file")" && realpath "$local_path" 2>/dev/null || echo "")"
                if [[ "$resolved_path" == "$PROJECT_ROOT"* ]] && [[ -n "$resolved_path" ]]; then
                    local project_rel_path="${resolved_path#$PROJECT_ROOT/}"
                    local new_display="§/$project_rel_path"
                    local new_local_path="$rel_path/$project_rel_path"
                    
                    local new_line=$(echo "$line" | sed -E "s|\[([^]]*)\]\(([^)]+)\)(\s*)$|[$new_display]($new_local_path)|")
                    echo "$new_line" >> "$temp_file"
                    changes_made=$((changes_made + 1))
                    echo -e "   ✅ Converted relative: $local_path → $new_display"
                else
                    echo "$line" >> "$temp_file"
                fi
            else
                echo "$line" >> "$temp_file"
            fi
        else
            echo "$line" >> "$temp_file"
        fi
    done < "$pdca_file"
    
    # Replace original file if changes were made
    if [[ $changes_made -gt 0 ]]; then
        mv "$temp_file" "$pdca_file"
        echo -e "   ${GREEN}✅ Fixed $changes_made dual links${NC}"
        rm "$backup_file"
        return 0
    else
        rm "$temp_file"
        rm "$backup_file"
        echo -e "   ${YELLOW}ℹ️  No dual links found to fix${NC}"
        return 1
    fi
}

# Function to process directory recursively
process_directory() {
    local dir="$1"
    local total_files=0
    local fixed_files=0
    
    echo -e "${BLUE}📁 Processing directory: $dir${NC}"
    
    # Find all PDCA markdown files
    while IFS= read -r -d '' file; do
        if [[ "$file" == *.md ]] && [[ "$(basename "$file")" != "README.md" ]]; then
            total_files=$((total_files + 1))
            if fix_pdca_file "$file"; then
                fixed_files=$((fixed_files + 1))
            fi
        fi
    done < <(find "$dir" -type f -name "*.md" -print0)
    
    echo -e "${GREEN}📊 Processed $total_files files, fixed $fixed_files files${NC}"
}

# Main execution
main() {
    local target="${1:-$PROJECT_ROOT/scrum.pmo/project.journal}"
    
    # Check if target exists
    if [[ ! -e "$target" ]]; then
        echo -e "${RED}❌ Target not found: $target${NC}"
        exit 1
    fi
    
    # Normalize path
    target="$(realpath "$target")"
    
    echo -e "${BLUE}🎯 Target: $target${NC}"
    
    if [[ -f "$target" ]]; then
        # Single file
        if fix_pdca_file "$target"; then
            echo -e "${GREEN}✅ Successfully fixed dual links in: $target${NC}"
        else
            echo -e "${YELLOW}ℹ️  No changes needed in: $target${NC}"
        fi
    elif [[ -d "$target" ]]; then
        # Directory
        process_directory "$target"
    else
        echo -e "${RED}❌ Target is neither file nor directory: $target${NC}"
        exit 1
    fi
    
    echo -e "${GREEN}🎉 PDCA Dual Link fixing complete!${NC}"
    echo -e "${BLUE}📋 Compliance with requirement: e8535c4e-591d-4955-9874-6a853545e970${NC}"
}

# Show usage if help requested
if [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
    echo "Usage: $0 [file-or-directory]"
    echo ""
    echo "Automatically fixes dual links in PDCA files to comply with dual link standard."
    echo "Uses § notation for readable display and correct relative paths for functionality."
    echo ""
    echo "Options:"
    echo "  file-or-directory    Target file or directory (default: scrum.pmo/project.journal)"
    echo "  --help, -h          Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0                                    # Fix all PDCAs in project.journal"
    echo "  $0 path/to/specific.pdca.md          # Fix specific PDCA file"  
    echo "  $0 scrum.pmo/project.journal/2025-*  # Fix PDCAs in specific session"
    echo ""
    echo "Dual Link Format (per requirement e8535c4e-591d-4955-9874-6a853545e970):"
    echo "  [GitHub](url) | [§/path/from/root](../../../path/from/document)"
    exit 0
fi

main "$@"
