#!/bin/bash
# Web4Articles - PDCA Dual Link Fixer
# Automatically fixes dual links in PDCA files to comply with requirement e8535c4e-591d-4955-9874-6a853545e970
# Usage: fix-pdca-dual-links [file-or-directory]

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Find project root
find_project_root() {
    local current_dir="$(pwd)"
    while [[ "$current_dir" != "/" ]]; do
        if [[ -f "$current_dir/.git/config" ]] || [[ -d "$current_dir/.git" ]]; then
            echo "$current_dir"
            return 0
        fi
        current_dir="$(dirname "$current_dir")"
    done
    echo "Error: Not in a git repository" >&2
    exit 1
}

PROJECT_ROOT=$(find_project_root)
source "$PROJECT_ROOT/source.env" >/dev/null 2>&1 || true

echo -e "${BLUE}ðŸ”§ Web4Articles PDCA Dual Link Fixer${NC}"
echo -e "${BLUE}ðŸ“‹ Requirement: e8535c4e-591d-4955-9874-6a853545e970${NC}"
echo -e "${BLUE}ðŸŽ¯ Project Root: $PROJECT_ROOT${NC}"

# Function to calculate relative path from document to project root
calculate_relative_path() {
    local doc_path="$1"
    local doc_dir="$(dirname "$doc_path")"
    local rel_path=""
    
    # Get absolute path to document directory
    doc_dir="$(realpath "$doc_dir")"
    
    # Count directory depth from project root by counting path components
    local relative_to_root="${doc_dir#$PROJECT_ROOT/}"
    
    # Handle case where document is in project root
    if [[ "$relative_to_root" == "$doc_dir" ]] || [[ -z "$relative_to_root" ]]; then
        echo "."
        return
    fi
    
    # Count actual directory levels (non-empty components only)
    local depth=0
    IFS='/' read -ra ADDR <<< "$relative_to_root"
    for component in "${ADDR[@]}"; do
        if [[ -n "$component" ]]; then
            depth=$((depth + 1))
        fi
    done
    
    # Build relative path with correct number of ../
    for ((i=0; i<depth; i++)); do
        rel_path="../$rel_path"
    done
    
    # Remove trailing slash if present
    rel_path="${rel_path%/}"
    
    echo "$rel_path"
}

# Function to fix dual links in a single PDCA file
fix_pdca_file() {
    local pdca_file="$1"
    local backup_file="${pdca_file}.bak"
    
    echo -e "${YELLOW}ðŸ“„ Processing: $pdca_file${NC}"
    
    # Create backup
    cp "$pdca_file" "$backup_file"
    
    # Calculate relative path from this document to project root
    local rel_path=$(calculate_relative_path "$pdca_file")
    if [[ -z "$rel_path" ]]; then
        rel_path="."
    fi
    
    echo -e "   ðŸ“ Relative path to project root: ${rel_path}"
    
    # Create temporary file for processing
    local temp_file=$(mktemp)
    
    # Process the file line by line
    local changes_made=0
    while IFS= read -r line; do
        # Check if line contains dual link pattern: [GitHub](...) | [local](path)
        if [[ "$line" =~ \[GitHub\]\([^)]+\)[[:space:]]*\|[[:space:]]*\[([^]]*)\]\(([^)]+)\) ]]; then
            local display_text="${BASH_REMATCH[1]}"
            local local_path="${BASH_REMATCH[2]}"
            
            # Skip if already using Â§ notation
            if [[ "$display_text" == "Â§"/* ]]; then
                echo "$line" >> "$temp_file"
                continue
            fi
            
            # Convert absolute project paths to Â§ notation and relative paths
            if [[ "$local_path" == "$PROJECT_ROOT"* ]]; then
                # Convert absolute path to project-relative
                local project_rel_path="${local_path#$PROJECT_ROOT/}"
                local new_display="Â§/$project_rel_path"
                local new_local_path="$rel_path/$project_rel_path"
                
                # Replace the local link part
                local new_line=$(echo "$line" | sed -E "s|\[([^]]*)\]\(([^)]+)\)(\s*)$|[$new_display]($new_local_path)|")
                echo "$new_line" >> "$temp_file"
                changes_made=$((changes_made + 1))
                echo -e "   âœ… Fixed: $display_text â†’ $new_display"
            elif [[ "$local_path" == /* ]] && [[ ! "$local_path" == "$rel_path"* ]]; then
                # Absolute path that's not project root - try to make relative
                if [[ "$local_path" == "$PROJECT_ROOT"* ]]; then
                    local project_rel_path="${local_path#$PROJECT_ROOT/}"
                    local new_display="Â§/$project_rel_path"  
                    local new_local_path="$rel_path/$project_rel_path"
                    
                    local new_line=$(echo "$line" | sed -E "s|\[([^]]*)\]\(([^)]+)\)(\s*)$|[$new_display]($new_local_path)|")
                    echo "$new_line" >> "$temp_file"
                    changes_made=$((changes_made + 1))
                    echo -e "   âœ… Fixed absolute path: $local_path â†’ $new_display"
                else
                    echo "$line" >> "$temp_file"
                fi
            elif [[ "$local_path" == ../* ]]; then
                # Already relative path - convert display to Â§ notation if possible
                # Try to resolve the relative path to see if it's in project
                local resolved_path="$(cd "$(dirname "$pdca_file")" && realpath "$local_path" 2>/dev/null || echo "")"
                if [[ "$resolved_path" == "$PROJECT_ROOT"* ]] && [[ -n "$resolved_path" ]]; then
                    local project_rel_path="${resolved_path#$PROJECT_ROOT/}"
                    local new_display="Â§/$project_rel_path"
                    
                    local new_line=$(echo "$line" | sed -E "s|\[([^]]*)\]\(([^)]+)\)|[$new_display]($local_path)|")
                    echo "$new_line" >> "$temp_file"
                    changes_made=$((changes_made + 1))
                    echo -e "   âœ… Updated display: $display_text â†’ $new_display"
                else
                    echo "$line" >> "$temp_file"
                fi
            elif [[ ! "$local_path" == $rel_path* ]] && [[ -f "$(dirname "$pdca_file")/$local_path" ]]; then
                # Relative path that needs to be updated to use project root reference
                local resolved_path="$(cd "$(dirname "$pdca_file")" && realpath "$local_path" 2>/dev/null || echo "")"
                if [[ "$resolved_path" == "$PROJECT_ROOT"* ]] && [[ -n "$resolved_path" ]]; then
                    local project_rel_path="${resolved_path#$PROJECT_ROOT/}"
                    local new_display="Â§/$project_rel_path"
                    local new_local_path="$rel_path/$project_rel_path"
                    
                    local new_line=$(echo "$line" | sed -E "s|\[([^]]*)\]\(([^)]+)\)(\s*)$|[$new_display]($new_local_path)|")
                    echo "$new_line" >> "$temp_file"
                    changes_made=$((changes_made + 1))
                    echo -e "   âœ… Converted relative: $local_path â†’ $new_display"
                else
                    echo "$line" >> "$temp_file"
                fi
            else
                echo "$line" >> "$temp_file"
            fi
        else
            echo "$line" >> "$temp_file"
        fi
    done < "$pdca_file"
    
    # Replace original file if changes were made
    if [[ $changes_made -gt 0 ]]; then
        mv "$temp_file" "$pdca_file"
        echo -e "   ${GREEN}âœ… Fixed $changes_made dual links${NC}"
        rm "$backup_file"
        return 0
    else
        rm "$temp_file"
        rm "$backup_file"
        echo -e "   ${YELLOW}â„¹ï¸  No dual links found to fix${NC}"
        return 1
    fi
}

# Function to process directory recursively
process_directory() {
    local dir="$1"
    local total_files=0
    local fixed_files=0
    
    echo -e "${BLUE}ðŸ“ Processing directory: $dir${NC}"
    
    # Find all PDCA markdown files
    while IFS= read -r -d '' file; do
        if [[ "$file" == *.md ]] && [[ "$(basename "$file")" != "README.md" ]]; then
            total_files=$((total_files + 1))
            if fix_pdca_file "$file"; then
                fixed_files=$((fixed_files + 1))
            fi
        fi
    done < <(find "$dir" -type f -name "*.md" -print0)
    
    echo -e "${GREEN}ðŸ“Š Processed $total_files files, fixed $fixed_files files${NC}"
}

# Main execution
main() {
    local target="${1:-$PROJECT_ROOT/scrum.pmo/project.journal}"
    
    # Check if target exists
    if [[ ! -e "$target" ]]; then
        echo -e "${RED}âŒ Target not found: $target${NC}"
        exit 1
    fi
    
    # Normalize path
    target="$(realpath "$target")"
    
    echo -e "${BLUE}ðŸŽ¯ Target: $target${NC}"
    
    if [[ -f "$target" ]]; then
        # Single file
        if fix_pdca_file "$target"; then
            echo -e "${GREEN}âœ… Successfully fixed dual links in: $target${NC}"
        else
            echo -e "${YELLOW}â„¹ï¸  No changes needed in: $target${NC}"
        fi
    elif [[ -d "$target" ]]; then
        # Directory
        process_directory "$target"
    else
        echo -e "${RED}âŒ Target is neither file nor directory: $target${NC}"
        exit 1
    fi
    
    echo -e "${GREEN}ðŸŽ‰ PDCA Dual Link fixing complete!${NC}"
    echo -e "${BLUE}ðŸ“‹ Compliance with requirement: e8535c4e-591d-4955-9874-6a853545e970${NC}"
}

# Show usage if help requested
if [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
    echo "Usage: $0 [file-or-directory]"
    echo ""
    echo "Automatically fixes dual links in PDCA files to comply with dual link standard."
    echo "Uses Â§ notation for readable display and correct relative paths for functionality."
    echo ""
    echo "Options:"
    echo "  file-or-directory    Target file or directory (default: scrum.pmo/project.journal)"
    echo "  --help, -h          Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0                                    # Fix all PDCAs in project.journal"
    echo "  $0 path/to/specific.pdca.md          # Fix specific PDCA file"  
    echo "  $0 scrum.pmo/project.journal/2025-*  # Fix PDCAs in specific session"
    echo ""
    echo "Dual Link Format (per requirement e8535c4e-591d-4955-9874-6a853545e970):"
    echo "  [GitHub](url) | [Â§/path/from/root](../../../path/from/document)"
    exit 0
fi

main "$@"
